# redis集群搭建

* 下载安装redis（具体操作查看之前的笔记）

* 创建目录

  ```cmd
  cd redis-5.0.5
  mkdir cluster
  cd cluster
  mkdir 7000 7001 7002 7003 7004 7005
  ```

* 复制修改配置文件

  * 复制配置文件到每个文件夹中

    ```cmd
    cd redis-5.0.5
    cp redis.conf cluster/7000
    ```

  * 修改每个配置文件

    ```cmd
    # 端口号
    port 7000
    # 后台启动
    daemonize yes
    # 开启集群
    cluster-enabled yes
    #集群节点配置文件
    cluster-config-file nodes-7000.conf
    # 集群连接超时时间
    cluster-node-timeout 5000
    # 进程pid的文件位置
    pidfile /var/run/redis-7000.pid
    # 开启aof
    appendonly yes
    # aof文件路径
    appendfilename "appendonly-7005.aof"
    # rdb文件路径
    dbfilename dump-7000.rdb
    ```

* 创建启动脚本

  在redis目录下创建start.sh

  ```cmd
  #!/bin/bash
  bin/redis-server cluster/7000/redis.conf
  bin/redis-server cluster/7001/redis.conf
  bin/redis-server cluster/7002/redis.conf
  bin/redis-server cluster/7003/redis.conf
  bin/redis-server cluster/7004/redis.conf
  bin/redis-server cluster/7005/redis.conf
  ```

* 开启集群

  ```cmd
  redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 --cluster-replicas 1
  ```

* 连接集群

  ```cmd
  ./redis-cli -c -p 7000
  ```

# redis支持的数据结构

* STRING（字符串）

* LIST（列表）

* SET（集合）对键值进行散列，保证唯一性，所以无序

* HASH（散列）

* ZSET（有序集合）和散列一样都用于存储健值对

  有序集合中的键被称为成员，成员唯一，值被称为分值，分值必须为浮点数，可以根据分值以及分值的排序来访问元素。

# redis命令

http://redis.io/commands

**注意点**

* 字符串可以存储以下三种类型的值：
  * 字符串
  * 整数
  * 浮点数

* 如果用户对一个不存在的键或者一个保存了空串的键执行自增或者自减操作，那么Redis在执行操作时会将这个键的值当作是0来处理。如果用户尝试对一个值无法被解释为整数或者浮点数的字符串键执行自增或者自减操作，那么Redis将向用户返回一个错误。

* 在使用`SETRANGE`或`·SETBIT`命令对字符串进行写入的时候，如果字符串当前的长度不能满足写入的要求，那么Redis会自动地使用空字节（null）来将字符串扩展至所需的长度，然后才执行写入或者更新操作。在使用`GETRANGE`读取字符串的时候，超出字符串末尾的数据会被视为是空串，而在使用`GETBIT`读取二进制位串的时候，超出字符串末尾的二进制位会被视为是0。

# redis事务

Redis的基本事务（basic transaction）需要用到`MULTI`命令和`EXEC`命令，这种事务可以让一个客户端在不被其他客户端打断的情况下执行多个命令。在Redis里面，被`MULTI`命令和`EXEC`命令包围的所有命令会一个接一个地执行，直到所有命令都执行完毕为止。当一个事务执行完毕之后，Redis才会处理其他客户端的命令。

### 事务流水线

当Redis从一个客户端那里接收到`MULTI`命令时，Redis会将这个客户端之后发送的所有命令都放入到一个队列里面，直到这个客户端发送`EXEC`命令为止，然后Redis就会在不被打断的情况下，一个接一个地执行存储在队列里面的命令。因为这种特性，很多redis客户端都会等待所有命令出现后一起发送给服务器，然后等待接收到所有命令的回复为止，这种做法被称为流水线，可以减少客户端与服务器之间的网络通信次数。

### 非事务型流水线

即使不使用`MUITI`和`EXEC`命令也可以实现流水线特性，具体用法可查看具体客户端的实现方法，这里不赘述。

### redis事务命令

* `MULTI`/`EXEC`

* `WATCH`

  在用户使用`WATCH`命令对键进行监视之后，直到用户执行`EXEC`命令的这段时间里面，如果有其他客户端抢先对任何被监视的键进行了替换、更新或删除等操作，那么当用户尝试执行`EXEC`命令的时候，事务将失败并返回一个错误

* `UNWATCH`/`DISCARD`

  `UNWATCH`命令可以在`WATCH`命令执行之后、`MULTI`命令执行之前对连接进行重置；同样地，`DISCARD`命令也可以在`MULTI`命令执行之后、`EXEC`命令执行之前对连接进行重置。

## redis键的过期时间

对于列表、集合、散列和有序集合这样的容器来说，键的过期命令只能为整个键设置，不能为键里面的单个元素设置过期时间。

# redis持久化

* 快照

  将存在于某一时刻的所有数据都写入硬盘中。

  创建快照的办法有以下几种：

  * 客户端可以通过向Redis发送`BGSAVE`命令来创建一个快照。Redis会调用fork来创建一个子进程，然后子进程负责将快照写入硬盘，而父进程继续处理命令请求。
  * 客户端还可以通过向Redis发送`SAVE`命令来创建一个快照，接到`SAVE`命令的Redis服务器在快照创建完毕之前将不再响应任何其他命令。
  * 如果用户设置了save配置选项，比如`save 60 10000`，那么从Redis最近一次创建快照之后开始算起，当“60秒之内有10000次写入”这个条件被满足时，Redis就会自动触发`BGSAVE`命令。如果用户设置了多个save配置选项，那么当任意一个save配置选项所设置的条件被满足时，Redis就会触发一次`BGSAVE`命令。
  * 当Redis通过`SHUTDOWN`命令接收到关闭服务器的请求时，或者接收到标准TERM信号时，会执行一个`SAVE`命令，阻塞所有客户端，不再执行客户端发送的任何命令，并在`SAVE`命令执行完毕之后关闭服务器。
  * 当一个Redis服务器连接另一个Redis服务器，并向对方发送`SYNC`命令来开始一次复制操作的时候，如果主服务器目前没有在执行`BGSAVE`操作，或者主服务器并非刚刚执行完`BGSAVE`操作，那么主服务器就会执行`BGSAVE`命令。

* AOP（追加文件）

  在执行写命令时，将被执行的写命令复制到硬盘中。

  通过`appendsync`配置选项可以对AOF文件的同步频率进行设置：

  * always每个redis命令都要写入硬盘
  * everysec每秒执行一次同步
  * no操作系统决定

  为了解决AOF文件体积不断增大的问题，用户可以向redis发送`BGREWRITEAOF`命令，redis会创建子进程通过移除AOF文件中的冗余命令来重写AOF。通过设置`autoaofrewritepercentage`选项和`autoaofrewriteminsize`选项来自动定期执行`BGREWRITEAOF`命令。

# redis复制

用户在启动Redis服务器的时候，指定了一个包含`slaveof host port`选项的配置文件，那么Redis服务器将根据该选项给定的IP地址和端口号来连接主服务器。对于一个正在运行的Redis服务器，用户可以通过发送`SLAVEOF no one`命令来让服务器终止复制操作，不再接受主服务器的数据更新；也可以通过发送`SLAVEOF host port`命令来让服务器开始复制一个新的主服务器。

## redis复制步骤

* 从服务器连接主服务器，发送`sync`命令
* 主服务器执行`BGSAVE`，并使用缓冲区记录`BGSAVE`之后执行的所有命令。从服务器根据配置选项决定是否继续处理请求。
* 主服务器`BGSAVE`执行结束后向从服务器发送快照文件，同时使用缓冲区继续记录执行的写操作。从服务器丢弃所有旧数据，载入快照文件。
* 主服务器向从服务器发送缓冲区中的写命令。从服务器载入快照文件后开始接受命令请求。
* 主服务器缓冲区的命令发送结束后，每执行一条写命令就会向从服务器发送。从服务器执行主服务器发来的缓冲区的写命令，然后开始接受并执行主服务器发送的命令。

每当有从服务器尝试与主服务器建立连接的时候，主服务器就会为从服务器创建一个快照，如果在快照创建完毕之前，有多个从服务器都尝试与主服务器进行连接，那么这些从服务器将接收到同一个快照。但是同时向多个从服务器发送快照的多个副本，可能会将主服务器可用的大部分带宽消耗殆尽。

## 检验硬盘写入

检查`INFO`命令的输出结果中`aof_pending_bio_fsync`属性的值是否为0，如果是的话，那么就表示服务器已经将已知的所有数据都保存到硬盘里面了。

## 验证快照文件和AOF文件

* `redis-check-aof`

  `redis-check-aof --fix`会对AOF文件进行修复，他会扫描给定的AOF文件，寻找不正确或者不完整的命令，当发现第一次出错的命令时会删除当前命令以及之后的所有命令。

* `redis-check-dump`

# redis性能优化

redis提供了性能测试程序`redis-benchmark`，默认情况运行该程序将使用50个客户端来进行测试，通过提供参数可以调节的，该命令会执行一些常用的redis命令。redis性能问题主要存在以下两种：

* 没有使用流水线。
* 对于每个命令或者每组命令都创建了新的连接（可重用redis连接）。

# 使用redis构建锁

## 普通锁

`setnx key value`命令会在给定的key值不存在的情况下将键key的值设为value，该命令是构建redis锁的核心命令。

## 超时锁

通过还命令获取锁后，可利用`EXPIRE`命令来设置锁的过期时间，使得redis能够自动删除超时的锁。确保锁在客户端奔溃的情况下可以自动过释放。

# 短结构

## 压缩列表

在列表、散列和有序集合的长度较短或者体积较小的时候，Redis可以选择使用一种名为压缩列表（ziplist）的紧凑存储方式来存储这些结构。为了确保压缩列表只会在有需要降低内存占用的情况下使用，Redis引入了以下几个配置选项，当超过了下面的阈值，Redis就会将相应的列表、散列或是有序集合从压缩列表编码转换为其他结构，且这种转换是不可逆的。

* list-max-ziplist-entries//在被编码为压缩列表的情况下允许包含的最大元素数量

  list-max-ziplist-value  //压缩列表每个节点的最大体积是多少字节

* hash-max-ziplist-entries

  hash-max-ziplist-value

* zset-max-ziplist-entries

  zset-max-ziplist-value

使用debug object可以了解一个对象是否被存为压缩列表。

## 整数集合

如果集合包含的所有成员都可以被解释为十进制整数，而这些整数又处于平台的有符号整数范围之内，并且集合成员的数量又足够少的话（具体的限制大小稍后就会说明，配置项：set-max-intset-entries），那么Redis就会以有序整数数组的方式存储集合，这种存储方式又被称为整数集合。

# Lua脚本拓展

将脚本载入Redis需要用到一个名为SCRIPTLOAD的命令，这个命令接受一个字符串格式的Lua脚本为参数，它会把脚本存储起来等待之后使用，然后返回被存储脚本的SHA1校验和。之后，用户只要调用EVALSHA命令，并输入脚本的SHA1校验和以及脚本所需的全部参数就可以调用之前存储的脚本。

Lua脚本跟单个Redis命令以及"MULTI"/"EXEC"事务一样，都是原子操作。对于不执行任何写命令的只读脚本来说，用户可以在脚本的运行时间超过luatimelimit选项指定的时间之后，执行SCRIPT KILL命令杀死正在运行的脚本。如果脚本已经对Redis存储的数据进行了写入，那么杀死脚本将导致Redis存储的数据进入一种不一致的状态。在这种情况下，用户唯一能够使用的恢复（recover）手段就是使用SHUTDOWN NOSAVE命令杀死Redis服务器，这将导致Redis丢失最近一次创建快照之后或者最近一次将命令写入AOF文件之后数据发生的所有变化。

## 缓存问题的解决方法

![img](https://static001.geekbang.org/resource/image/b5/e1/b5bd931239be18bef24b2ef36c70e9e1.jpg)

* 缓存穿透

  用户查询一个在数据库中不存在的数据，当然也不会存在缓存中。

  解决方案：

  * 布隆过滤器，把所有可能存在的值哈希到一个足够大的bitmap中

  * 查数据库返回为空，我们同样缓存该空值

* 缓存雪崩

  解决方法：

  * 交错失效时间
  * 缓存不存在时上锁区数据库捞然后重建缓存

* 缓存击穿

  热点数据缓存失效，缓存雪崩中的一种。

  解决方法：

  * 为热点数据设置二级缓存，并且过期时间交错
  * LRU缓存淘汰算法：LRU，LRU-K，2Q，MQ
  
* 缓存污染

  缓存数据被访问次数很少，但是还继续占用缓存空间

  解决方法：

  * LRU（访问时间）缺点：批量查询数据大量数据的访问时间相同，但是访问次数很少
  * LFU（访问次数+访问时间）