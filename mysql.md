# Mysql基本架构图

<img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdan88cdyfj311o0sa7gy.jpg" alt="截屏2020-03-29 上午11.36.13" style="zoom:50%;" />

## 连接器

用户建立连接后，在这期间如果该用户的权限发生变化不会影响当前连接，重新连接后才会使用新的权限设置。我们可以通过show processlist查看当前所有的连接状态，wait_timeout参数可以设置客户端连接空闲多久会自动断开。Mysql存在长连接和短连接，长连接指的是如果客户端持续有请求会一直使用同一个连接，短连接是指每次执行完很少的几次请求会就会断开，下次请求再次建立连接。长连接占内存，可以使用mysql_reset_connection重置连接资源，该命令不会进行重连只是将连接恢复到刚创建的状态。

# Update的执行流程

WAL:Write-Ahead Logging（先写日志在写磁盘）

redo log是InnoDB特有的日志，Server层也有自己的日志binlog。

redo log是物理日志（记录的是具体的数据页上做的具体的修改）；binlog是逻辑日志（请求的语句逻辑），binlog存在两种模式：statement（记录的sql）和row（记录行数据，更新前后）

redo log是固定大小的，采用循环写的方法；binlog追加写不会覆盖之前的日志激励。

更新语句的执行流程图：

<img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdb4k7s7qoj30rw12mwtd.jpg" alt="截屏2020-03-29 下午9.35.51" style="zoom:50%;" />

## 二阶段提交

上图中redo日志的写入分为两步，成为二阶段提交，目的是使的binlog和redo log保持一致。

innodb_flush_log_at_trx_commit 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。

sync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。

# 事物隔离

存在多个事物会导致的问题：

* 脏读
* 不可重复读
* 幻读（只针对于新插入的行）

事物隔离级别

* read uncommitted
* read committed
* repeatable read（默认）
* serializable

因事物隔离造成对多个事物的显示数据的不同是通过视图实现的，根据隔离级别视图返回相应的数据。

## 事物隔离的实现

每条记录在更新是都会生成相应的回滚记录，通过回滚可以将当前值恢复到上一个状态，下面的图显示一个值从1改成2，3，4生成的回滚记录。同一条记录存在多个版本数据，这就是数据库的多版本并发控制（MVCC），不同版本的数据都是当前值根据回滚记录进行回滚得到的。回滚日志在不需要的时候会被删除，所以长事物会导致回滚日志占用大量存储空间。

<img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdb5jb2h8tj316o0iwtgb.jpg" alt="截屏2020-03-29 下午10.09.38" style="zoom:50%;" />

多版本数据库通过transaction id和事物进行绑定。更新数据时要先读后写，这里的读不再是返回对应的版本数据，而是当前值，读取当前值需要加行级锁。普通的select语句也可以进行当前读，只需要加上加上 lock in share mode（共享锁，读锁） 或 for update（排他锁，写锁）限制就行，所以当前读会设计到锁的竞争。

<img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdejhg175lj30xg0g40za.jpg" alt="截屏2020-04-01 下午8.28.39" style="zoom:50%;" />

# 索引

主键索引（聚集索引）和非主键索引（二级索引），主键索引的叶子结点存的是整行数据，非主键索引的叶子结点存的是主键索引。非主键索引会多查一棵索引树，称为回表。

覆盖索引可以减少回表次数。

最左匹配原则

索引下推

## change buffer

当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。需要说明的是，虽然名字叫作 change buffer，实际上它是可以持久化的数据。也就是说，change buffer 在内存中有拷贝，也会被写入到磁盘上。将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 merge。除了访问这个数据页会触发 merge 外，系统有后台线程会定期 merge。在数据库正常关闭（shutdown）的过程中，也会执行 merge 操作。

但是对于唯一索引来说，每次更新都要判断唯一性，所以必须将数据读入内存，所以唯一索引的更新无法使用change buffer特性，普通索引可以。

change buffer的修改也会记录相应的redo log， 在执行merge操作时因为内存数据发生了变化所以会生成相应的redo log。

## 索引的选择

索引的选择是在优化器中实现的，优化器会通过扫描行数来判断选择哪个索引。但是数据库并不是每次都会选择对的索引，遇到这个种情况可以通过以下方式解决：

* analyze table 命令可以修正数据库的统计信息（查询行数）
* 在语句中加上force index强制使用某个索引
* 修改语句引导数据库选择合适的语句

Mysql 采用标记删除，不会立即从索引和数据文件中删除数据。

对于长字符串来说可以利用mysql的前缀索引机制，只取字符串的前几个字符建立索引。利用前缀索引时要保证索引的区分度，不然会导致扫描行数的增加。前缀索引还会导致覆盖索引的失效，增加回表的次数。

对索引字段做函数操作时，会破坏索引字段的有序性，导致数据库放弃使用该索引。

当索引字段和给定的索引值之间的类型不同，数据库会进行隐式的类型转化，可能会对索引字段进行函数操作。

当执行联结表查询时，如果两个表的字符编码不同会导致连接字段进行隐式的编码转化。

# 锁

全局锁，表级锁，行级锁，间隔锁（gap）

注意：锁是加在索引上的，加载不同索引上的锁不会相互冲突

表级锁有两种，一种是通过lock tables手动上锁，另一种表锁被称为MDL（意思就是表结构锁）。MDL不需要显示的添加，MDL锁在语句开始执行的时候申请，但是当语句执行结束后并不会立即释放，而是等到整个事物提交后再释放。MDL锁的获取是通过队列的方式实现的，只要上一次申请的是写锁，那么后续的锁申请都会被阻塞。

行级锁的实现是在引擎层，在innodb中行锁是在需要的时候才会加上，但并不是不需要了就会立即释放，而是要等到事物结束时才释放，所以你的事物中需要锁多行，那应该将最容易造成锁冲突和影响并发度的锁往后放。

当出现死锁时数据库提供了两种策略：

* 等待直到超时，超时时间可以通过参数 innodb_lock_wait_timeout 来设置
* 发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。

innodb的行级锁是通过锁索引实现的，如果没有索引会锁定整张表。

不同种类的锁之间是相互独立的，如果有多个锁存在必须全部不互斥才能进行。

间隔锁是为了解决幻读的问题，行级锁只能锁住行对于新插入行无法阻止，插入操作改变的是行之间的间隙，所以引入间隔锁，间隔锁只在可重复读的隔离级别下才会生效。间隔锁在并发的时候可能会导致死锁。

Mysql的加锁规则：

* 原则 1：加锁的基本单位是 next-key lock。希望你还记得，next-key lock 是前开后闭区间。
* 原则 2：查找过程中访问到的对象才会加锁。
* 优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。
* 优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。
* 一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。

在读提交隔离级别下还有一个优化，即：语句执行过程中加上的行锁，在语句执行完成后，就要把“不满足条件的行”上的行锁直接释放了，不需要等到事务提交。

# Mysql 刷脏时机

* redo log满了，redo log需要覆盖之前的记录，这个时候需要将覆盖的redo log对应的数据页刷新到磁盘
* 内存满了，需要淘汰内存中的数据页，这个时候如果淘汰的数据页是脏页就要刷新到磁盘
* Mysql 空闲时
* Mysql正常关闭时

刷脏时如果当前数据页的旁边的数据页刚好也是脏页时会一起刷脏，该机制可以通过innodb_flush_neighbors参数进行设置。此外innodb_io_capacity参数表示当前主机的磁盘能力，数据库会根据该值设置刷脏策略。

# 空间回收

Innodb里面的数据都是采用B+树的结构组织的。数据被删除时只是做个删除标记，不会立即回收占用空间，下次有数据添加时就会复用该空间。当一条记录被删除时，下次只有在合适范围内的数据添加时才会复用标记删除的空间，但是如果一个数据页的所有记录都被删除了，那么该数据页可以随便复用。出了删除会造成空间浪费，插入和更新同样会，插入如果造成数据页分裂会导致导致空间浪费，更新可以理解为删除插入。

重建表可以回收上述的空间浪费，alter table t engine = InnoDB。

online DDL：意思是在重建表的过程中，允许对表做增删改操作。大概原理就是在重建的过程中对该表的增删改操作会被记录在一个日志中，重建结束后在新表上应用日志。

# Order by的执行原理

排序操作是在一个叫sort buffer的内存区域进行的，数据库将符合条件的数据查处放在sort buffer中进行排序，如果sort buffer过小，会利用临时文件通过归并排序的方法进行排序。如果需要排序的单条记录过大，数据库会只把主键字段和排序字段放在sort buffer中，排序结束后根据主键字段回表查询其他对应的字段。

联合索引可以提高排序的效率，如果条件字段和排序字段建立的联合索引，那么在进行查询前获取到的满足条件的数据集中排序字段便是直接有序的，就不需要再进行排序操作，此外联合索引还能减少回表次数。

# 单行查询慢

可能存在一下几种情况：

* 查询长时间不返回（show processlist 命令查一下）
  * 等MDL锁
  * 等flush
  * 等行锁
* 查询慢，可能是因为事物原因该查询不是当前读，需要应用回滚日志回滚到相应的版本。

# Mysql持久化

## binlog的写入机制

binlog 的写入逻辑比较简单：事务执行过程中，先把日志写到 binlog cache，事务提交的时候，再把 binlog cache 写到 binlog 文件中。一个事务的 binlog 是不能被拆开的，因此不论这个事务多大，也要确保一次性写入。系统给 binlog cache 分配了一片内存，每个线程一个，参数 binlog_cache_size 用于控制单个线程内 binlog cache 所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。

<img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdht9n4a8ej30ti0ji0yi.jpg" alt="截屏2020-04-04 下午4.24.05" style="zoom:50%;" />

图中的write操作就是指把日志写入到文件系统的 page cache，fsync才是将日志持久化到磁盘文件。fsync的时机由参数sync_binlog控制：

* sync_binlog=0 的时候，表示每次提交事务都只 write，不 fsync；
* sync_binlog=1 的时候，表示每次提交事务都会执行 fsync；
* sync_binlog=N(N>1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。

binlog格式包含三种：row，statement，mixed。row占用空间大，statement会引起主备不一致，所以出现了mixed格式，mixed格式时数据库会判断当前语句是否会引起主备不一致，如果是就会用row格式存储binlog。

Mysql的主备复制通过binlog实现，从库可以通过多线程执行主库binlog来提高效率，缩短主备不一致的时间。多线程在进行任务分发是必须注意一下几个条件，否则会导致主备不一致：

* 不能造成更新覆盖。这就要求更新同一行的两个事务，必须被分发到同一个 worker 中。
* 同一个事务不能被拆开，必须放到同一个 worker 中。

主备不一致的问题是不能完全避免的，在开发中可能遇到更新后立即查找，此时因为主备不一致可能会导致查询结果为更新前的内容，这种现象称为过期读，可以的解决方案主要包含以下几种：

* 强制走主库方案；
* sleep 方案；
* 判断主备无延迟方案；
  * show slave status 结果里的 seconds_behind_master 参数的值是否为0
  * 如果 Master_Log_File 和 Relay_Master_Log_File、Read_Master_Log_Pos 和 Exec_Master_Log_Pos 这两组值完全相同，就表示接收到的日志已经同步完成。Master_Log_File 和 Read_Master_Log_Pos，表示的是读到的主库的最新位点；Relay_Master_Log_File 和 Exec_Master_Log_Pos，表示的是备库执行的最新位点。
  * Auto_Position=1 ，表示这对主备关系使用了 GTID 协议。Retrieved_Gtid_Set，是备库收到的所有日志的 GTID 集合；Executed_Gtid_Set，是备库所有已经执行完成的 GTID 集合。如果这两个集合相同，也表示备库接收到的日志都已经同步完成。
* 配合 semi-sync 方案；（所有给客户端发送过确认的事务，都确保了备库已经收到了这个日志）
* 等主库位点方案；
* 等 GTID 方案。

主备同步流程图：

<img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdk2p2y41mj30tm0kejy8.jpg" alt="截屏2020-04-06 下午3.21.20" style="zoom:50%;" />

## redo log的写入机制

<img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdhtud3b42j30gq0b6gmq.jpg" alt="截屏2020-04-04 下午4.44.00" style="zoom:50%;" />

为了控制 redo log 的写入策略，InnoDB 提供了 innodb_flush_log_at_trx_commit 参数，它有三种可能取值：

* 设置为 0 的时候，表示每次事务提交时都只是把 redo log 留在 redo log buffer 中 ;
* 设置为 1 的时候，表示每次事务提交时都将 redo log 直接持久化到磁盘；
* 设置为 2 的时候，表示每次事务提交时都只是把 redo log 写到 page cache。

InnoDB 有一个后台线程，每隔 1 秒，就会把 redo log buffer 中的日志，调用 write 写到文件系统的 page cache，然后调用 fsync 持久化到磁盘。事务执行中间过程的 redo log 也是直接写在 redo log buffer 中的，这些 redo log 也会被后台线程一起持久化到磁盘。也就是说，一个没有提交的事务的 redo log，也是可能已经持久化到磁盘的。除此之外，当redo log buffer占用的空间超过指定的一半时会主动写盘，或者并行的事物提交时会顺带把该为提交事物的redo log buffer写盘。

并发事物的redo log会进行组提交，减少磁盘的写入次数。

# 误删数据的解决方案

* delete语句，可是通过binlog进行恢复（Flashback工具）
* drop删除表/库，备份数据+binlog，可以搞一个延迟复制的备库

# 查询结果发送流程

<img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdk4f6v3m0j30sk0ksdif.jpg" alt="截屏2020-04-06 下午4.21.10" style="zoom:50%;" />

* 获取一行，写到 net_buffer 中。这块内存的大小是由参数 net_buffer_length 定义的，默认是 16k。
* 重复获取行，直到 net_buffer 写满，调用网络接口发出去。
* 如果发送成功，就清空 net_buffer，然后继续取下一行，并写入 net_buffer。
* 如果发送函数返回 EAGAIN 或 WSAEWOULDBLOCK，就表示本地网络栈（socket send buffer）写满了，进入等待。直到网络栈重新可写，再继续发送。

从上述流程可以看出mysql是边读边发的，大数据量的查询并不会导致内存占满。

自增id并不能保证是连续的，因为如果语句执行失败，生成的自增id并不会回退。