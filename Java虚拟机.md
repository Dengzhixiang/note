# 虚拟机内存模型

<img src="https://static001.geekbang.org/resource/image/ab/77/ab5c3523af08e0bf2f689c1d6033ef77.png" alt="img" style="zoom:50%;" />

虚拟机将字节码编译成机器码的两种方法：（虚拟机默认采用混合的方式）

* 解释执行：将字节码逐条翻译成机器码执行
* 即时编译：将一个方法中包含的所有字节码编译成机器码后再执行

虚拟机中将boolean类型当作int，true为1，false为0；if（flag）判断是将flag与0做判断。

## 对象的内存布局

<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkgnsx0fc7j310u0man2x.jpg" alt="截屏2020-11-07 下午3.51.47" style="zoom:50%;" />

Mark Word：4字节（32）；8字节（64）

Class Pointer：4字节（32）；8字节（64）

Length：4字节

java对象占用空间是8字节对齐的

64位下开启指针压缩，指针大小位4字节

java中常见的新建对象的方式：new；反射；Object.clone；序列化

虚拟机会对字段进行重排序使字段的内存分布满足以下条件：

* 如果一个字段占据 C 个字节，那么该字段的偏移量需要对齐至 NC。
* 子类所继承字段的偏移量，需要与父类对应字段的偏移量保持一致。

java8引入了新的注释：@Contended，使得被注释字段处于独立的缓存行中，防止虚共享的情况。

计算机基本单位：位；字节（8位）；字（表示cpu一次能处理的实际位数）

java基本类型的大小：

|   类型    | 长度（字节） |
| :-------: | :----------: |
|   byte    |      1       |
|  boolean  |      1       |
|    int    |      4       |
|   short   |      2       |
|   long    |      8       |
|   char    |      2       |
|   float   |      4       |
|  double   |      8       |
| reference |     4/8      |

# 类加载过程

虚拟机的类加载过程：

* 加载
* 链接
* 初始化

## 加载

虚拟机类加载器：

* 启动类加载器
* 拓展类加载器
* 应用类加载器

在Java虚拟机中类的唯一性是由类加载器实例以及类名共同决定的。

## 链接

链接过程分为：

* 验证：虚拟机约束条件检查
* 准备：静态字段分配内存；构造和类层次相关的数据结构
* 解析：符号引用解析为实际引用，如果符号引用指向一个未被加载的类将会触发对该类的加载。对于静态绑定实际引用是一个指向方法的指针，对于动态绑定实际引用指向的是一个方法表的索引。符号引用存储在class文件的常量池中。

## 初始化

虚拟机通过加锁确保类的初始化方法仅被执行一次。

类的初始化时机：

* 虚拟机启动，初始化用户指定的主类
* new
* 调用静态方法初始化该方法所在的类
* 访问静态字段时初始化该字段坐在的类
* 子类初始化会触发父类的初始化
* 如果接口定义了default方法，直接或间接实现该接口的类的初始化会触发该接口的初始化
* 反射
* 当初次调用 MethodHandle（和反射类似）实例时，初始化该 MethodHandle 指向的方法所在的类

# 方法调用

重载：同一方法内，方法名相同，参数类型不同

重载方法的选择定位：

* 不考虑自动拆装箱和可变长参数
* 考虑自动拆装箱，不考虑可变长参数
* 考虑自动拆装箱和可变长参数

重写（多态的表现）：存在继承关系的类之间，方法名相同，参数类型相同，返回类型相同

虚拟机识别方法的关键在于类名，方法名以及方法描述符。方法描述符：方法参数类型+返回类型。

方法调用的指令：

* invokestatic
* invokespecial
* invokevirtual
* invokeinterface
* invokedynamic（应用程序可以自行决定具体的调用目标，lambda表达式就是借助该指令实现的）

## 动态绑定

为了实现动态绑定，java虚拟机为每个类生成了一张方法表，用于快速定位目标方法。方法表具有一下两个特征：

* 子类方法表中包含父类方法表中的所有方法
* 子类方法在方法表中的索引值和它所重写的父类方法的索引值相同

方法调用指令中的符号引用会在执行之前解析成实际引用。对于静态绑定的方法调用而言，实际引用将指向具体的目标方法。对于动态绑定的方法调用而言，实际引用则是方法表的索引值。在执行过程中，Java 虚拟机将获取调用者的实际类型，并在该实际类型的虚方法表中，根据索引值获得目标方法。

## 内联缓存

内联缓存是一种加快动态绑定的优化技术。它能够缓存虚方法调用中调用者的动态类型，以及该类型所对应的目标方法。在之后的执行过程中，如果碰到已缓存的类型，内联缓存便会直接调用该类型所对应的目标方法。如果没有碰到已缓存的类型，内联缓存则会退化至使用基于方法表的动态绑定。

## 方法内联

在编译过程中遇到方法调用时，将目标方法的方法体纳入编译范围之中，并取代原方法调用的优化手段。

方法内联的触发条件：

* 由 -XX:CompileCommand 中的 inline 指令指定的方法
* @ForceInline 注解的方法（仅限于 JDK 内部方法）

## 虚拟机异常处理

在编译生成的字节码中，每个方法都附带一个异常表。异常表中的每一个条目代表一个异常处理器，并且由 from 指针、to 指针、target 指针以及所捕获的异常类型构成。其中from 指针和 to 指针表示该异常处理器所监控的范围，target 指针则指向异常处理器的起始位置。

# 垃圾回收

Java虚拟机采用可达性分析算法标示需要回收的内存，相较于计数器可达性分析算法可以解决循环引用的问题。

为了防止多线程环境下可达性分析算法可能造成的误报和漏报，GC时会停止其他非GC线程直到GC完成。当 Java 虚拟机收到 Stop-the-world 请求，它便会等待所有的线程都到达安全点（在该时间点虚拟机的堆栈不会发生变化），才允许请求 Stop-the-world 的线程进行独占的工作。

垃圾回收的三种方式：

* 清除：内存碎片，内存分配时需要查询空闲内存列表，效率低
* 压缩：将存活对象聚集到内存起始位置，压缩算法开销大
* 复制：内存分为两部分

## 分代回收思想

将堆空间划分为新生代和老年代，新生代用来存储新建的对象，当存活对象存活时间够长时则移动到老年代，新生代又被划分为Eden区和两个大小相同的Survivor区。Eden和Survivor的比例可以通过-XX:+UsePSAdaptiveSurvivorSizePolicy或者-XX:SurvivorRatio进行配置，前者根据不同的策略进行动态配置，后者配置固定比例。

<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkhqgz5l4ij30u009udgu.jpg" alt="截屏2020-11-08 下午2.09.41" style="zoom:50%;" />

当新建对象时一般会在Eden区进行内存分配，这个分配操作需要同步，防止在多线程下不同对象占用相同的内存空间。Java虚拟机采用TLAB技术，每个线程会预先申请一段连续的内存空间，当前线程的内存分配就在这段内存上操作，这个申请操作需要加锁。通过参数-XX:+UseTLAB可以开关这个特性。

### Minor GC

当Eden区空间耗尽Java虚拟机就会触发一次Minor GC，对新生代进行垃圾回收。当发生 Minor GC 时，Eden 区和 from 指向的 Survivor 区中的存活对象会被复制到 to 指向的 Survivor 区中，然后交换 from 和 to 指针。Java 虚拟机会记录 Survivor 区中的对象一共被来回复制了几次。如果一个对象被复制的次数为 15（对应虚拟机参数 -XX:+MaxTenuringThreshold），那么该对象将被晋升（promote）至老年代。另外，如果单个 Survivor 区已经被占用了 50%（对应虚拟机参数 -XX:TargetSurvivorRatio），那么较高复制次数的对象也会被晋升至老年代。

### 卡表

Minor GC的优势就是不用对整个堆空间进行扫描，但是可能老年代中会有对新生代的引用，那么在可达性分析的时候就会对老年代进行扫描。为了防止这种全堆扫描的情况，引入了卡表功能，将整个堆分为512字节的卡，并维护一张卡表存储每张卡是否可能存在指向新生代对象的引用。

# Java内存模型

as-if-serial：经过重排序的执行结果要与顺序执行的结果一致

happen-before：如果操作X happen-before 操作Y，那么X的结果对于Y可见（锁，volatile）

java锁的分类：

<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkj6dgz9puj30vg0aytd8.jpg" alt="截屏2020-11-09 下午8.05.27" style="zoom:50%;" />

# 逃逸分析

方法内联后判断对象是否会逃出方法外（自己的理解）。

基于逃逸分析的优化：

* 锁消除
* 新建对象操作转换为栈上分配或者标量替换